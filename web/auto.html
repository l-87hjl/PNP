<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automatic Generator - P vs NP</title>
    <link rel="stylesheet" href="styles.css">
    <script src="utils.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>‚ö° Automatic Instance Generator</h1>
            <p class="subtitle">Generate random lock instances with customizable parameters</p>
            <a href="index.html" class="btn btn-secondary" style="margin-top: 15px;">‚Üê Back to Home</a>
        </header>

        <!-- Generator Interface -->
        <div class="builder-container">
            <!-- Left Panel: Parameters -->
            <div class="control-panel">
                <!-- Instance Type Selection -->
                <div class="control-section">
                    <h3>Instance Type</h3>
                    <div class="form-group">
                        <label style="display: flex; align-items: center; margin-bottom: 10px; cursor: pointer;">
                            <input type="radio" name="instanceType" value="solvable" checked style="margin-right: 10px;">
                            <div>
                                <strong>Solvable Instance</strong>
                                <p style="font-size: 0.85rem; color: var(--text-muted); margin: 3px 0 0 0;">
                                    Guaranteed to have a valid solution
                                </p>
                            </div>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="instanceType" value="random" style="margin-right: 10px;">
                            <div>
                                <strong>Random Instance</strong>
                                <p style="font-size: 0.85rem; color: var(--text-muted); margin: 3px 0 0 0;">
                                    May or may not be solvable (use solver to verify)
                                </p>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Parameters -->
                <div class="control-section">
                    <h3>Generation Parameters</h3>

                    <div class="form-group">
                        <label for="numVars">Number of Variables (Dials): <span id="numVarsValue">10</span></label>
                        <input type="range" id="numVars" min="3" max="50" value="10"
                               oninput="updateSliderValue('numVars', 'numVarsValue')"
                               style="width: 100%;">
                    </div>

                    <div class="form-group">
                        <label for="numClauses">Number of OR Clauses: <span id="numClausesValue">15</span></label>
                        <input type="range" id="numClauses" min="3" max="100" value="15"
                               oninput="updateSliderValue('numClauses', 'numClausesValue')"
                               style="width: 100%;">
                    </div>

                    <div class="form-group">
                        <label for="negProb">Negation Probability: <span id="negProbValue">20</span>%</label>
                        <input type="range" id="negProb" min="0" max="50" value="20"
                               oninput="updateSliderValue('negProb', 'negProbValue')"
                               style="width: 100%;">
                        <p style="font-size: 0.85rem; color: var(--text-muted); margin-top: 5px;">
                            Percentage of variables with negation links
                        </p>
                    </div>

                    <button class="btn btn-primary" style="width: 100%;" onclick="generateInstance()">
                        Generate Instance
                    </button>
                    <div id="genMessage"></div>
                </div>

                <!-- Statistics -->
                <div class="control-section" id="statsSection" style="display: none;">
                    <h3>Statistics</h3>
                    <div id="statsDisplay"></div>
                </div>

                <!-- Download Buttons -->
                <div class="control-section" id="downloadSection" style="display: none;">
                    <h3>Download</h3>
                    <button class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;" onclick="downloadInstance()">
                        üíæ Download Instance
                    </button>
                    <button class="btn btn-secondary" style="width: 100%;" onclick="downloadSolution()">
                        ‚úÖ Download Solution
                    </button>
                </div>
            </div>

            <!-- Right Panel: Output -->
            <div class="visualization-panel">
                <h3>Generated Instance & Solution</h3>

                <!-- Instance JSON -->
                <div style="margin-bottom: 20px;">
                    <h4 style="color: var(--accent-blue); margin-bottom: 10px;">Instance JSON:</h4>
                    <pre id="instanceJson" style="background-color: var(--bg-tertiary); padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 0.9rem; max-height: 300px;">
Click "Generate Instance" to create a random lock configuration</pre>
                </div>

                <!-- Solution JSON -->
                <div style="margin-bottom: 20px;">
                    <h4 style="color: var(--accent-green); margin-bottom: 10px;">Solution JSON:</h4>
                    <pre id="solutionJson" style="background-color: var(--bg-tertiary); padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 0.9rem; max-height: 300px;">
Solution will appear here</pre>
                </div>

                <!-- Visualization -->
                <div>
                    <h4 style="color: var(--accent-purple); margin-bottom: 10px;">Visualization:</h4>
                    <canvas id="generatorCanvas" width="700" height="500"></canvas>
                    <div class="legend" style="margin-top: 15px;">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #3fb950; width: 30px; height: 30px; border-radius: 50%;"></div>
                            <span>Dial set to TRUE (6)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #f85149; width: 30px; height: 30px; border-radius: 50%;"></div>
                            <span>Dial set to FALSE (1)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // Automatic Instance Generator JavaScript
        // ============================================

        // Global state
        let generatedInstance = null;
        let generatedSolution = null;

        /**
         * Update slider value display
         */
        function updateSliderValue(sliderId, displayId) {
            const value = document.getElementById(sliderId).value;
            document.getElementById(displayId).textContent = value;
        }

        /**
         * Generate a random lock instance
         * Strategy depends on instance type:
         * - Solvable: Create solution first, then generate clauses that satisfy it
         * - Random: Generate random clauses without ensuring satisfiability
         */
        function generateInstance() {
            const msgDiv = document.getElementById('genMessage');

            // Get parameters
            const numVars = parseInt(document.getElementById('numVars').value);
            const numClauses = parseInt(document.getElementById('numClauses').value);
            const negProb = parseInt(document.getElementById('negProb').value) / 100;

            // Get instance type
            const instanceType = document.querySelector('input[name="instanceType"]:checked').value;

            showMessage(msgDiv, 'Generating instance...', 'success', 0);

            // Generate based on type
            if (instanceType === 'random') {
                generateRandomInstance(numVars, numClauses, negProb, msgDiv);
            } else {
                generateSolvableInstance(numVars, numClauses, negProb, msgDiv);
            }
        }

        /**
         * Generate a truly random instance (may or may not be solvable)
         */
        function generateRandomInstance(numVars, numClauses, negProb, msgDiv) {
            // Step 1: Create random negation links
            const negations = [];
            const numNegations = Math.floor(numVars * negProb / 2); // Pairs

            // Shuffle dials and pair them
            const availableDials = Array.from({length: numVars}, (_, i) => i + 1);
            shuffleArray(availableDials);

            for (let i = 0; i < numNegations * 2 - 1; i += 2) {
                if (i + 1 < availableDials.length) {
                    const dial1 = availableDials[i];
                    const dial2 = availableDials[i + 1];
                    negations.push([dial1, dial2]);
                }
            }

            // Step 2: Generate completely random OR clauses
            const clauses = [];
            for (let i = 0; i < numClauses; i++) {
                const clause = getRandomDistinctDials(numVars, 3);
                clauses.push(clause);
            }

            // Step 3: Build instance (no solution)
            generatedInstance = {
                num_dials: numVars,
                binary_pins: Array.from({length: numVars}, (_, i) => i + 1),
                negations: negations,
                clauses: clauses
            };

            generatedSolution = null; // No solution for random instances

            // Display results
            displayResults();

            showMessage(msgDiv, 'Random instance generated successfully!', 'success', 3000);
        }

        /**
         * Generate a solvable instance (guaranteed to have a valid solution)
         */
        function generateSolvableInstance(numVars, numClauses, negProb, msgDiv) {

            // Step 1: Create a random solution
            const solution = {};
            for (let i = 1; i <= numVars; i++) {
                // Randomly assign TRUE (6) or FALSE (1)
                solution[i] = Math.random() < 0.5 ? 1 : 6;
            }

            // Step 2: Create negation links
            const negations = [];
            const numNegations = Math.floor(numVars * negProb / 2); // Pairs

            // Shuffle dials and pair them
            const availableDials = Array.from({length: numVars}, (_, i) => i + 1);
            shuffleArray(availableDials);

            for (let i = 0; i < numNegations * 2 - 1; i += 2) {
                if (i + 1 < availableDials.length) {
                    const dial1 = availableDials[i];
                    const dial2 = availableDials[i + 1];

                    // Add negation and adjust solution to satisfy it
                    negations.push([dial1, dial2]);

                    // Ensure dial1 + dial2 = 7
                    if (solution[dial1] === 6) {
                        solution[dial2] = 1;
                    } else {
                        solution[dial2] = 6;
                    }
                }
            }

            // Step 3: Generate OR clauses that are satisfied by the solution
            const clauses = [];

            // Create a map of which dials are in negation links
            const negationMap = new Map();
            for (const [dial1, dial2] of negations) {
                negationMap.set(dial1, dial2);
                negationMap.set(dial2, dial1);
            }

            for (let i = 0; i < numClauses; i++) {
                // Pick 3 random distinct dials
                const clause = getRandomDistinctDials(numVars, 3);

                // If clause is not satisfied by current solution, flip one dial to TRUE
                const sum = solution[clause[0]] + solution[clause[1]] + solution[clause[2]];
                if (sum < 8) {
                    // Find a dial in the clause that's FALSE and make it TRUE
                    // IMPORTANT: Prefer dials NOT in negation links to avoid breaking constraints
                    let flipped = false;

                    // First try dials not in negations
                    for (const dial of clause) {
                        if (solution[dial] === 1 && !negationMap.has(dial)) {
                            solution[dial] = 6;
                            flipped = true;
                            break;
                        }
                    }

                    // If all are in negations, carefully flip and update the negated pair
                    if (!flipped) {
                        for (const dial of clause) {
                            if (solution[dial] === 1) {
                                solution[dial] = 6;
                                // Update its negation pair if it exists
                                if (negationMap.has(dial)) {
                                    const partner = negationMap.get(dial);
                                    solution[partner] = 1; // Ensure sum = 7
                                }
                                break;
                            }
                        }
                    }
                }

                clauses.push(clause);
            }

            // Step 4: Build instance and solution objects
            generatedInstance = {
                num_dials: numVars,
                binary_pins: Array.from({length: numVars}, (_, i) => i + 1),
                negations: negations,
                clauses: clauses
            };

            generatedSolution = {
                dial_values: solution
            };

            // CRITICAL: Validate solution before displaying
            const validation = validateCompleteSolution(generatedInstance, solution);
            if (!validation.isValid) {
                console.error("Generated invalid solution:", validation.errors);
                showMessage(msgDiv, 'Error: Generated invalid solution. Retrying...', 'error', 2000);
                // Retry with different random seed
                setTimeout(generateInstance, 100);
                return;
            }

            // Display results
            displayResults();

            showMessage(msgDiv, 'Solvable instance generated successfully!', 'success', 3000);
        }

        /**
         * Validate a complete solution against all constraints
         */
        function validateCompleteSolution(instance, dialValues) {
            const errors = [];

            // Check all dials are set
            for (let i = 1; i <= instance.num_dials; i++) {
                if (!dialValues[i] && dialValues[i] !== 0) {
                    errors.push(`Dial ${i} not set`);
                }
            }

            // Check binary constraints
            instance.binary_pins.forEach(dial => {
                const val = dialValues[dial];
                if (val !== 1 && val !== 6) {
                    errors.push(`Binary constraint violated: Dial ${dial} = ${val}, must be 1 or 6`);
                }
            });

            // Check negations (CRITICAL - this is where the bug manifests)
            instance.negations.forEach(([i, j]) => {
                const sum = dialValues[i] + dialValues[j];
                if (sum !== 7) {
                    errors.push(`Negation violated: Not(${i},${j}) - ${dialValues[i]} + ${dialValues[j]} = ${sum}, must equal 7`);
                }
            });

            // Check OR clauses
            instance.clauses.forEach(([i, j, k]) => {
                const sum = dialValues[i] + dialValues[j] + dialValues[k];
                if (sum < 8) {
                    errors.push(`OR clause violated: (${i},${j},${k}) - sum = ${sum}, must be >= 8`);
                }
            });

            return {
                isValid: errors.length === 0,
                errors: errors
            };
        }

        /**
         * Get N random distinct dials
         */
        function getRandomDistinctDials(maxDial, count) {
            const dials = [];
            const used = new Set();

            while (dials.length < count) {
                const dial = Math.floor(Math.random() * maxDial) + 1;
                if (!used.has(dial)) {
                    dials.push(dial);
                    used.add(dial);
                }
            }

            return dials;
        }

        /**
         * Fisher-Yates shuffle
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Display generated instance and solution
         */
        function displayResults() {
            // Display instance JSON
            document.getElementById('instanceJson').textContent =
                JSON.stringify(generatedInstance, null, 2);

            // Display solution JSON
            if (generatedSolution) {
                document.getElementById('solutionJson').textContent =
                    JSON.stringify(generatedSolution, null, 2);
            } else {
                document.getElementById('solutionJson').textContent =
                    'No solution generated (random instance - use solver to find solution)';
            }

            // Display statistics
            let statusText, statusColor, statusNote;
            if (generatedSolution) {
                statusText = '‚úì SATISFIABLE';
                statusColor = 'var(--accent-green)';
                statusNote = 'This instance was generated to be satisfiable by construction';
            } else {
                statusText = '? UNKNOWN';
                statusColor = 'var(--accent-purple)';
                statusNote = 'This is a random instance - satisfiability unknown. Use the solver to verify.';
            }

            const statsHtml = `
                <div style="background-color: var(--bg-tertiary); padding: 15px; border-radius: 6px;">
                    <div style="margin-bottom: 8px;"><strong>Dials:</strong> ${generatedInstance.num_dials}</div>
                    <div style="margin-bottom: 8px;"><strong>Negations:</strong> ${generatedInstance.negations.length}</div>
                    <div style="margin-bottom: 8px;"><strong>Clauses:</strong> ${generatedInstance.clauses.length}</div>
                    <div style="margin-bottom: 8px;"><strong>Status:</strong> <span style="color: ${statusColor};">${statusText}</span></div>
                    <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 10px;">
                        ${statusNote}
                    </div>
                </div>
            `;
            document.getElementById('statsDisplay').innerHTML = statsHtml;
            document.getElementById('statsSection').style.display = 'block';
            document.getElementById('downloadSection').style.display = 'block';

            // Update download solution button state
            const downloadSolutionBtn = document.querySelector('button[onclick="downloadSolution()"]');
            if (generatedSolution) {
                downloadSolutionBtn.disabled = false;
                downloadSolutionBtn.style.opacity = '1';
                downloadSolutionBtn.style.cursor = 'pointer';
            } else {
                downloadSolutionBtn.disabled = true;
                downloadSolutionBtn.style.opacity = '0.5';
                downloadSolutionBtn.style.cursor = 'not-allowed';
            }

            // Visualize with solution (if available)
            visualizeLock(generatedInstance, 'generatorCanvas', generatedSolution);
        }

        /**
         * Download generated instance
         */
        function downloadInstance() {
            if (!generatedInstance) {
                alert('Please generate an instance first');
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            downloadJson(generatedInstance, `lock_instance_${timestamp}.json`);
        }

        /**
         * Download generated solution
         */
        function downloadSolution() {
            if (!generatedInstance) {
                alert('Please generate an instance first');
                return;
            }

            if (!generatedSolution) {
                alert('No solution available for random instances.\n\nUse the Solver page to find a solution for this instance.');
                return;
            }

            // CRITICAL: Validate before download
            const validation = validateCompleteSolution(generatedInstance, generatedSolution.dial_values);

            if (!validation.isValid) {
                alert("Cannot download: Solution is invalid!\n\n" + validation.errors.join("\n"));
                console.error("Solution validation failed:", validation.errors);
                return;  // Don't download
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            downloadJson(generatedSolution, `lock_solution_${timestamp}.json`);
        }

        // Initialize visualization
        window.onload = function() {
            const canvas = document.getElementById('generatorCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#8b949e';
            ctx.font = '18px var(--font-sans)';
            ctx.textAlign = 'center';
            ctx.fillText('Generate an instance to see visualization', canvas.width / 2, canvas.height / 2);
        };
    </script>
</body>
</html>
